## FLA实验报告

### 分析与设计思路

实验要求我们实现一个确定性下推自动机模拟器和一个多带图灵机模拟器. 由于这两种自动机的逻辑已经足够简单，模拟逻辑很容易实现，只需要在C++中选取合适的数据结构辅助完成即可:

- 对于下推自动机里的栈，使用`std::stack`模拟

- 对于多带图灵机里的多条纸带，使用`std::vector<std::deque>`模拟，也即用一个双端队列表示一条纸带，这样表示的方便在于图灵机纸带是双向延展的，而双端队列也可以两头插入弹出，刚好能模拟这个行为

- 对于转移的查询，直接使用`std::map`，例如对于图灵机，查询使用的key为`std::tuple<StateSymbol, std::vector<TapeSymbol>>`，即使用当前状态以及各纸带读出内容作为查询依据. 对于通配符，我们直接枚举`std::map`当中所有的键值对，按照通配符的意义寻找匹配的转移.

有了以上的设计之后模拟逻辑就容易实现了.

### 实验完成度

- 模拟器: 100%. 可以模拟合法的DPDA与TM，没有状态数或转移数限制.

- 解析器: 70%. 可以报告出绝大多数语法错误，如状态名打错，纸带符号输错，少了`{`或`}`等. 完全严谨(形式化角度完全正确)的解析器没有实现. 以及对语法错误的提示由于过于繁琐也没有实现.

- PDA程序与TM程序: 100%. 要求编写的PDA程序和TM程序都已实现，且对于各种大小规模的输入都能输出正确结果，空输入等corner case也测试通过.

- verbose模式: 90%. 图灵机的verbose模式可以完整打印每一步的状态，如纸带内容、读写头位置、下标列表等，并能对齐输出，达到非常易读的效果. 提示TM程序语法错误的部分没有实现(但会给出syntax error). PDA的verbose模式没有实现.

### 实验中遇到的问题与解决方案

实验中遇到的问题主要在TM程序的设计上:

- 通配符

由于手册的规定里，通配符匹配**空白以外的所有字符**，而设计TM程序时，有时需要空白字符也能匹配.

解决方案: 对需要匹配空白字符的那条纸带，复制出新的一份转移，将通配符改为空白符. 这在纸带数增多时将导致转移指数级增加，因此需要通过更好的程序逻辑设计予以弥补.

- 输入输出均在首条纸带

由于手册规定图灵机应该把输出写在第一条纸带，也即输入的纸带上，边读取输入边输出将导致程序设计的复杂.

解决方案: 增加一条纸带，程序开始时把输入拷到此纸带上，同时擦除输入纸带上的内容，使其始终为空，直到输出状态时才开始写入. `case2.tm`就用到了此技巧.

- 完全平方识别程序的设计

此程序需要能够判断1的个数是否为完全平方数. 如果采用平方的定义，我们将需要某种乘法程序以计算平方，或许我们可以把`case1.tm`的乘法程序拿来作为子程序，然而结合程序的其他部分之后，这将会使整个程序异常复杂. 可以采用以加法代替乘法的解决方案.

解决方案: 观察到`1=1,1+3=4,1+3+5=9,1+3+5+7=16`，我们可以用等差数列的求和生成每一个完全平方数. 故我们设计两条纸带，一条叫`s`，表示当前所枚举到的完全平方数，一条叫`a`，表示得到下一个完全平方数所需的增量，每一次我们只需令`s+=a; a+=2`即可. 考虑到加法设计是简单的，故上述设计能尽量简化程序.

### 总结感想

本次实验通过设计一个可运行的模拟器，并使用verbose模式可视化输出，让我以形象的方式看到了图灵机运行的细节，具象化了课堂内的抽象概念.

同时，设计图灵机程序的过程让我体会到，图灵机的计算能力是足够强大的，并不因为其模型的简单而弱于实际的编程语言，问题只是在于如何简化程序的设计上. 我再一次深刻体会到，用简单模型描述复杂世界的理论魅力.

### 对课程实验的意见和建议

课程实验总体上让我们体会到了由理论到实际、由抽象到具象的自动机学习过程，也试图让我们了解实践中关于命令行工具规范的事宜，但有些部分细节已过于繁琐而失去意义，如：

- 解析自定义TM/PDA程序的语法

此过程无异于为一个新语言实现一个编译器. 考虑到字符串处理的海量细节，这个过程几乎占去整个实验一半的时间，远与实验目的相悖. 我们完全可以有更好的方法定义一个TM/PDA程序：内嵌在已有的编程语言里，语法解析交给已有的编译器，我们只解析语义. 例如，用一个`hello.json`文件来描述一个输出`hello`的图灵机程序如下:

```json
{
    "Type": "TM Program",
    "State Alphabet": ["hello0", "hello1", "hello2", "hello3", "hello4", "halt_accept"],
    "Input Alphabet": [],
    "Tape Alphabet": ["h", "e", "l", "o", "_"],
    "Starting State": "hello0",
    "Terminating States": ["halt_accept"],
    "Number of Tapes": 2,
    "Blank Symbol": "_",
    "Transitions": [
        {
            "Type": "Transition tuple",
            "Current State": "hello0",
            "Symbol Read": ["*", "_"],
            "Next State": "hello1",
            "Symbol Write": ["*", "h"],
            "Pointer Movement": ["*", "r"]
        },
        {
            "Type": "Transition tuple",
            "Current State": "hello1",
            "Symbol Read": ["*", "_"],
            "Next State": "hello2",
            "Symbol Write": ["*", "e"],
            "Pointer Movement": ["*", "r"]
        },
        {
            "Type": "Transition tuple",
            "Current State": "hello2",
            "Symbol Read": ["*", "_"],
            "Next State": "hello3",
            "Symbol Write": ["*", "l"],
            "Pointer Movement": ["*", "r"]
        },
        {
            "Type": "Transition tuple",
            "Current State": "hello3",
            "Symbol Read": ["*", "_"],
            "Next State": "hello4",
            "Symbol Write": ["*", "l"],
            "Pointer Movement": ["*", "r"]
        },
        {
            "Type": "Transition tuple",
            "Current State": "hello4",
            "Symbol Read": ["*", "_"],
            "Next State": "halt_accept",
            "Symbol Write": ["*", "o"],
            "Pointer Movement": ["*", "*"]
        }
    ]
}
```

这样的描述方式有许多好处：

- 可以用已有的[解析器](https://github.com/nlohmann/json)解析语法，而无需陷入复杂的细节中，用更多的精力关注与课程内容更相关的语义解析部分

- json文件高度结构化，用其设计TM程序能使代码更加易读.

- 对于状态名、纸带字符等的规定能更进一步放宽，例如使用json定义TM程序，我们甚至可以在纸带的单个位置写入一个“字符串符号”，状态名也可以包含任意的字符